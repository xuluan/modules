# C++ 数据检查系统扩展性设计方案

## 当前问题分析

### 现有代码问题
```cpp
bool check_data(Testexpect* my_data, std::string attr_name, AttrData& attr_data, 
                std::map<std::string, AttrData>& variables, CheckPattern c)
{
    switch(c) {
        case CheckPattern::SAME:    
            return check_data_same(my_data, attr_name, attr_data, variables);
        case CheckPattern::ATTR_PLUS_MUL:  
            return check_data_plus_mul(my_data, attr_name, attr_data, variables);
        default:  
            throw std::runtime_error("check_data fail: Error CheckPattern");
    }
}
```

### 主要问题
1. **硬编码的switch语句**：每增加一种检查模式都需要修改enum和switch语句
2. **紧耦合**：检查逻辑直接嵌入在主函数中
3. **难以配置**：检查模式无法动态配置或组合
4. **扩展性差**：添加新的检查类型需要修改多个地方

---

## 方案1：策略模式 + 工厂模式

### 设计思路
使用策略模式将每种检查逻辑封装成独立的类，用工厂模式管理检查器的创建。

### 核心代码结构

```cpp
// 抽象检查策略接口
class DataChecker {
public:
    virtual ~DataChecker() = default;
    virtual bool check(Testexpect* my_data, const std::string& attr_name, 
                      AttrData& attr_data, std::map<std::string, AttrData>& variables) = 0;
    virtual std::string name() const = 0;
};

// 具体检查策略实现
class SameChecker : public DataChecker {
public:
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        return check_data_same(my_data, const_cast<std::string&>(attr_name), attr_data, variables);
    }
    std::string name() const override { return "SAME"; }
};

class AttrPlusMulChecker : public DataChecker {
public:
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        return check_data_plus_mul(my_data, const_cast<std::string&>(attr_name), attr_data, variables);
    }
    std::string name() const override { return "INLINE+CROSSLINE*2.7"; }
};

// 新的检查器示例
class RangeChecker : public DataChecker {
public:
    RangeChecker(double min_val, double max_val) : min_value(min_val), max_value(max_val) {}
    
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        float* data = static_cast<float*>(attr_data.data);
        int length = attr_data.length * my_data->group_size;
        
        for(int i = 0; i < length; ++i) {
            if(data[i] < min_value || data[i] > max_value) {
                return false;
            }
        }
        return true;
    }
    
    std::string name() const override { 
        return "RANGE[" + std::to_string(min_value) + "," + std::to_string(max_value) + "]"; 
    }
    
private:
    double min_value, max_value;
};

// 检查器工厂
class CheckerFactory {
public:
    using CheckerCreator = std::function<std::unique_ptr<DataChecker>()>;
    
    static CheckerFactory& instance() {
        static CheckerFactory factory;
        return factory;
    }
    
    void registerChecker(const std::string& name, CheckerCreator creator) {
        creators_[name] = creator;
    }
    
    std::unique_ptr<DataChecker> createChecker(const std::string& name) {
        auto it = creators_.find(name);
        if (it != creators_.end()) {
            return it->second();
        }
        return nullptr;
    }
    
    void initializeDefaultCheckers() {
        registerChecker("SAME", []() { return std::make_unique<SameChecker>(); });
        registerChecker("INLINE+CROSSLINE*2.7", []() { return std::make_unique<AttrPlusMulChecker>(); });
    }
    
private:
    std::unordered_map<std::string, CheckerCreator> creators_;
};

// 更新后的检查函数
bool check_data_v2(Testexpected* my_data, const std::string& attr_name, 
                   AttrData& attr_data, std::map<std::string, AttrData>& variables, 
                   const std::string& pattern_name) {
    auto checker = CheckerFactory::instance().createChecker(pattern_name);
    if (!checker) {
        throw std::runtime_error("Unknown check pattern: " + pattern_name);
    }
    
    return checker->check(my_data, attr_name, attr_data, variables);
}
```

### 优点
- ✅ 易于理解和实现
- ✅ 类型安全
- ✅ 符合开闭原则
- ✅ 每个检查器职责单一

### 缺点
- ❌ 需要为每个检查器创建类
- ❌ 代码量较大
- ❌ 运行时多态有轻微性能开销

### 适用场景
- 检查逻辑相对复杂
- 需要类型安全
- 团队习惯面向对象设计

---

## 方案2：基于函数对象的轻量级方案

### 设计思路
使用std::function和lambda表达式，避免创建大量类，更加轻量级。

### 核心代码结构

```cpp
// 检查函数签名
using CheckFunction = std::function<bool(Testexpected*, const std::string&, AttrData&, std::map<std::string, AttrData>&)>;

// 检查器注册表
class CheckerRegistry {
public:
    static CheckerRegistry& instance() {
        static CheckerRegistry registry;
        return registry;
    }
    
    void registerChecker(const std::string& name, CheckFunction checker) {
        checkers_[name] = checker;
    }
    
    CheckFunction getChecker(const std::string& name) {
        auto it = checkers_.find(name);
        if (it != checkers_.end()) {
            return it->second;
        }
        return nullptr;
    }
    
    void initializeDefaultCheckers() {
        // 注册现有检查器
        registerChecker("SAME", [](Testexpected* my_data, const std::string& attr_name, 
                                  AttrData& attr_data, std::map<std::string, AttrData>& variables) {
            return check_data_same(my_data, const_cast<std::string&>(attr_name), attr_data, variables);
        });
        
        registerChecker("INLINE+CROSSLINE*2.7", [](Testexpected* my_data, const std::string& attr_name, 
                                                   AttrData& attr_data, std::map<std::string, AttrData>& variables) {
            return check_data_plus_mul(my_data, const_cast<std::string&>(attr_name), attr_data, variables);
        });
        
        // 新的检查器示例
        registerChecker("NON_ZERO", [](Testexpected* my_data, const std::string& attr_name, 
                                      AttrData& attr_data, std::map<std::string, AttrData>& variables) {
            float* data = static_cast<float*>(attr_data.data);
            int length = attr_data.length * my_data->group_size;
            for(int i = 0; i < length; ++i) {
                if(data[i] == 0.0f) return false;
            }
            return true;
        });
        
        registerChecker("POSITIVE", [](Testexpected* my_data, const std::string& attr_name, 
                                      AttrData& attr_data, std::map<std::string, AttrData>& variables) {
            float* data = static_cast<float*>(attr_data.data);
            int length = attr_data.length * my_data->group_size;
            for(int i = 0; i < length; ++i) {
                if(data[i] <= 0.0f) return false;
            }
            return true;
        });
    }
    
private:
    std::unordered_map<std::string, CheckFunction> checkers_;
};

// 支持参数化检查器的工厂函数
class ParametricCheckerFactory {
public:
    static CheckFunction createRangeChecker(double min_val, double max_val) {
        return [min_val, max_val](Testexpected* my_data, const std::string& attr_name, 
                                 AttrData& attr_data, std::map<std::string, AttrData>& variables) {
            float* data = static_cast<float*>(attr_data.data);
            int length = attr_data.length * my_data->group_size;
            for(int i = 0; i < length; ++i) {
                if(data[i] < min_val || data[i] > max_val) return false;
            }
            return true;
        };
    }
    
    static CheckFunction createFormulaChecker(const std::string& formula) {
        return [formula](Testexpected* my_data, const std::string& attr_name, 
                        AttrData& attr_data, std::map<std::string, AttrData>& variables) {
            // 根据formula字符串执行相应的检查逻辑
            // 可以集成简单的表达式解析器
            return true; // 占位符
        };
    }
};

// 更新后的检查函数
bool check_data_v2(Testexpected* my_data, const std::string& attr_name, 
                   AttrData& attr_data, std::map<std::string, AttrData>& variables, 
                   const std::string& pattern_name) {
    auto checker = CheckerRegistry::instance().getChecker(pattern_name);
    if (!checker) {
        throw std::runtime_error("Unknown check pattern: " + pattern_name);
    }
    
    return checker(my_data, attr_name, attr_data, variables);
}
```

### 优点
- ✅ 轻量级，易于添加新检查器
- ✅ 支持lambda表达式，代码简洁
- ✅ 无需创建大量类
- ✅ 性能较好

### 缺点
- ❌ 类型安全性相对较弱
- ❌ lambda闭包可能导致内存问题
- ❌ 调试相对困难

### 适用场景
- 快速原型开发
- 检查逻辑相对简单
- 注重开发效率

---

## 方案3：基于配置的复合检查器

### 设计思路
支持通过配置文件定义复杂的检查逻辑，包括AND/OR组合、嵌套检查等。

### 核心代码结构

```cpp
// 检查器基类
class BaseChecker {
public:
    virtual ~BaseChecker() = default;
    virtual bool check(Testexpected* my_data, const std::string& attr_name, 
                      AttrData& attr_data, std::map<std::string, AttrData>& variables) = 0;
    virtual void configure(const DynamicValue& config) {}
    virtual std::string describe() const = 0;
};

// 复合检查器 - 支持AND/OR逻辑
class CompositeChecker : public BaseChecker {
public:
    enum LogicOperator { AND, OR };
    
    CompositeChecker(LogicOperator op) : logic_op_(op) {}
    
    void addChecker(std::unique_ptr<BaseChecker> checker) {
        checkers_.push_back(std::move(checker));
    }
    
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        if (checkers_.empty()) return true;
        
        if (logic_op_ == AND) {
            for (const auto& checker : checkers_) {
                if (!checker->check(my_data, attr_name, attr_data, variables)) {
                    return false;
                }
            }
            return true;
        } else { // OR
            for (const auto& checker : checkers_) {
                if (checker->check(my_data, attr_name, attr_data, variables)) {
                    return true;
                }
            }
            return false;
        }
    }
    
    std::string describe() const override {
        std::string result = "(";
        std::string op_str = (logic_op_ == AND) ? " AND " : " OR ";
        
        for (size_t i = 0; i < checkers_.size(); ++i) {
            if (i > 0) result += op_str;
            result += checkers_[i]->describe();
        }
        result += ")";
        return result;
    }
    
private:
    LogicOperator logic_op_;
    std::vector<std::unique_ptr<BaseChecker>> checkers_;
};

// 具体检查器实现
class RangeChecker : public BaseChecker {
public:
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        float* data = static_cast<float*>(attr_data.data);
        int length = attr_data.length * my_data->group_size;
        
        for(int i = 0; i < length; ++i) {
            if(data[i] < min_value_ || data[i] > max_value_) {
                return false;
            }
        }
        return true;
    }
    
    void configure(const DynamicValue& config) override {
        min_value_ = config.get("min", DynamicValue(-1e6)).as_double();
        max_value_ = config.get("max", DynamicValue(1e6)).as_double();
    }
    
    std::string describe() const override {
        return "RANGE[" + std::to_string(min_value_) + "," + std::to_string(max_value_) + "]";
    }
    
private:
    double min_value_ = -1e6;
    double max_value_ = 1e6;
};

class StatisticalChecker : public BaseChecker {
public:
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        float* data = static_cast<float*>(attr_data.data);
        int length = attr_data.length * my_data->group_size;
        
        // 计算统计量
        double sum = 0, sum_sq = 0;
        for(int i = 0; i < length; ++i) {
            sum += data[i];
            sum_sq += data[i] * data[i];
        }
        
        double mean = sum / length;
        double variance = sum_sq / length - mean * mean;
        double std_dev = std::sqrt(variance);
        
        // 检查统计量是否符合要求
        return (mean >= min_mean_ && mean <= max_mean_ && 
                std_dev >= min_std_ && std_dev <= max_std_);
    }
    
    void configure(const DynamicValue& config) override {
        min_mean_ = config.get("min_mean", DynamicValue(-1e6)).as_double();
        max_mean_ = config.get("max_mean", DynamicValue(1e6)).as_double();
        min_std_ = config.get("min_std", DynamicValue(0.0)).as_double();
        max_std_ = config.get("max_std", DynamicValue(1e6)).as_double();
    }
    
    std::string describe() const override {
        return "STATS[mean:" + std::to_string(min_mean_) + "-" + std::to_string(max_mean_) + 
               ",std:" + std::to_string(min_std_) + "-" + std::to_string(max_std_) + "]";
    }
    
private:
    double min_mean_ = -1e6, max_mean_ = 1e6;
    double min_std_ = 0.0, max_std_ = 1e6;
};

// 检查器构建器
class CheckerBuilder {
public:
    static std::unique_ptr<BaseChecker> buildFromConfig(const DynamicValue& config) {
        std::string type = config.get("type", DynamicValue("")).as_string();
        
        if (type == "range") {
            auto checker = std::make_unique<RangeChecker>();
            checker->configure(config);
            return checker;
        } else if (type == "stats") {
            auto checker = std::make_unique<StatisticalChecker>();
            checker->configure(config);
            return checker;
        } else if (type == "composite") {
            std::string op = config.get("operator", DynamicValue("AND")).as_string();
            auto composite = std::make_unique<CompositeChecker>(
                op == "OR" ? CompositeChecker::OR : CompositeChecker::AND);
            
            const auto& checkers_config = config.get("checkers", DynamicValue::make_array()).as_array();
            for (const auto& checker_config : checkers_config) {
                auto sub_checker = buildFromConfig(checker_config);
                if (sub_checker) {
                    composite->addChecker(std::move(sub_checker));
                }
            }
            return composite;
        }
        
        return nullptr;
    }
};
```

### 配置示例

```yaml
# YAML配置示例
check_patterns:
  - name: "complex_validation"
    type: "composite"
    operator: "AND"
    checkers:
      - type: "range"
        min: 0.0
        max: 100.0
      - type: "stats"
        min_mean: 10.0
        max_mean: 90.0
        min_std: 1.0
        max_std: 15.0
  
  - name: "flexible_check"
    type: "composite"
    operator: "OR"
    checkers:
      - type: "range"
        min: -10.0
        max: 10.0
      - type: "composite"
        operator: "AND"
        checkers:
          - type: "range"
            min: 90.0
            max: 110.0
          - type: "stats"
            min_std: 0.1
            max_std: 2.0
```

### 优点
- ✅ 支持复杂的逻辑组合（AND/OR）
- ✅ 完全配置化，无需修改代码
- ✅ 支持嵌套检查
- ✅ 易于理解和维护

### 缺点
- ❌ 复杂度较高
- ❌ 配置解析开销
- ❌ 调试困难

### 适用场景
- 需要复杂的检查逻辑组合
- 检查规则需要频繁变更
- 配置驱动的系统

---

## 方案4：模板化的类型安全检查器

### 设计思路
使用C++模板提供完全的类型安全，在编译时确定数据类型，获得最佳性能。

### 核心代码结构

```cpp
// 类型安全的数据访问器
template<typename T>
class TypedDataAccessor {
public:
    TypedDataAccessor(AttrData& attr_data, int group_size) 
        : data_(static_cast<T*>(attr_data.data)), 
          length_(attr_data.length * group_size) {
        if (!data_) {
            throw std::runtime_error("Data pointer is null");
        }
    }
    
    T& operator[](size_t index) { return data_[index]; }
    const T& operator[](size_t index) const { return data_[index]; }
    size_t size() const { return length_; }
    T* data() const { return data_; }
    
private:
    T* data_;
    size_t length_;
};

// 模板化检查器基类
template<typename T>
class TypedChecker {
public:
    virtual ~TypedChecker() = default;
    virtual bool check(TypedDataAccessor<T>& data, 
                      std::map<std::string, AttrData>& variables,
                      Testexpected* context) = 0;
    virtual std::string name() const = 0;
};

// 具体的模板化检查器
template<typename T>
class RangeChecker : public TypedChecker<T> {
public:
    RangeChecker(T min_val, T max_val) : min_value_(min_val), max_value_(max_val) {}
    
    bool check(TypedDataAccessor<T>& data, 
              std::map<std::string, AttrData>& variables,
              Testexpected* context) override {
        for (size_t i = 0; i < data.size(); ++i) {
            if (data[i] < min_value_ || data[i] > max_value_) {
                return false;
            }
        }
        return true;
    }
    
    std::string name() const override {
        return "Range[" + std::to_string(min_value_) + "," + std::to_string(max_value_) + "]";
    }
    
private:
    T min_value_, max_value_;
};

template<typename T>
class MonotonicChecker : public TypedChecker<T> {
public:
    enum Direction { INCREASING, DECREASING, NON_DECREASING, NON_INCREASING };
    
    MonotonicChecker(Direction dir) : direction_(dir) {}
    
    bool check(TypedDataAccessor<T>& data, 
              std::map<std::string, AttrData>& variables,
              Testexpected* context) override {
        if (data.size() < 2) return true;
        
        for (size_t i = 1; i < data.size(); ++i) {
            switch (direction_) {
                case INCREASING:
                    if (data[i] <= data[i-1]) return false;
                    break;
                case DECREASING:
                    if (data[i] >= data[i-1]) return false;
                    break;
                case NON_DECREASING:
                    if (data[i] < data[i-1]) return false;
                    break;
                case NON_INCREASING:
                    if (data[i] > data[i-1]) return false;
                    break;
            }
        }
        return true;
    }
    
    std::string name() const override {
        static const char* names[] = {"Increasing", "Decreasing", "NonDecreasing", "NonIncreasing"};
        return names[direction_];
    }
    
private:
    Direction direction_;
};

// 统计检查器
template<typename T>
class StatisticsChecker : public TypedChecker<T> {
public:
    struct Stats {
        double mean, variance, std_dev, min_val, max_val;
    };
    
    StatisticsChecker(const Stats& expected, double tolerance = 1e-6) 
        : expected_(expected), tolerance_(tolerance) {}
    
    bool check(TypedDataAccessor<T>& data, 
              std::map<std::string, AttrData>& variables,
              Testexpected* context) override {
        Stats actual = calculateStats(data);
        
        return (std::abs(actual.mean - expected_.mean) <= tolerance_ &&
                std::abs(actual.std_dev - expected_.std_dev) <= tolerance_);
    }
    
    std::string name() const override {
        return "Statistics[mean=" + std::to_string(expected_.mean) + 
               ",std=" + std::to_string(expected_.std_dev) + "]";
    }
    
private:
    Stats expected_;
    double tolerance_;
    
    Stats calculateStats(TypedDataAccessor<T>& data) {
        Stats stats = {};
        if (data.size() == 0) return stats;
        
        double sum = 0, sum_sq = 0;
        stats.min_val = stats.max_val = static_cast<double>(data[0]);
        
        for (size_t i = 0; i < data.size(); ++i) {
            double val = static_cast<double>(data[i]);
            sum += val;
            sum_sq += val * val;
            stats.min_val = std::min(stats.min_val, val);
            stats.max_val = std::max(stats.max_val, val);
        }
        
        stats.mean = sum / data.size();
        stats.variance = sum_sq / data.size() - stats.mean * stats.mean;
        stats.std_dev = std::sqrt(stats.variance);
        
        return stats;
    }
};

// 类型分发器
class TypeDispatcher {
public:
    template<typename CheckerType>
    static bool dispatch(as::DataFormat format, AttrData& attr_data, int group_size,
                        std::map<std::string, AttrData>& variables, Testexpected* context,
                        CheckerType&& checker_factory) {
        switch (format) {
            case as::DataFormat::FORMAT_R32: {
                TypedDataAccessor<float> accessor(attr_data, group_size);
                auto checker = checker_factory.template create<float>();
                return checker->check(accessor, variables, context);
            }
            case as::DataFormat::FORMAT_R64: {
                TypedDataAccessor<double> accessor(attr_data, group_size);
                auto checker = checker_factory.template create<double>();
                return checker->check(accessor, variables, context);
            }
            case as::DataFormat::FORMAT_U32: {
                TypedDataAccessor<uint32_t> accessor(attr_data, group_size);
                auto checker = checker_factory.template create<uint32_t>();
                return checker->check(accessor, variables, context);
            }
            // 添加其他类型...
            default:
                throw std::runtime_error("Unsupported data format");
        }
    }
};

// 检查器工厂
struct RangeCheckerFactory {
    double min_val, max_val;
    
    template<typename T>
    std::unique_ptr<TypedChecker<T>> create() {
        return std::make_unique<RangeChecker<T>>(static_cast<T>(min_val), static_cast<T>(max_val));
    }
};

// 使用示例
bool check_data_typed(Testexpected* my_data, const std::string& attr_name, 
                     AttrData& attr_data, std::map<std::string, AttrData>& variables,
                     const std::string& pattern_name) {
    
    if (pattern_name.find("RANGE[") == 0) {
        // 解析范围参数
        RangeCheckerFactory factory{0.0, 100.0};
        return TypeDispatcher::dispatch(attr_data.type, attr_data, my_data->group_size,
                                       variables, my_data, factory);
    }
    
    return false;
}
```

### 优点
- ✅ 完全类型安全
- ✅ 性能最优（编译时优化）
- ✅ 支持任意数据类型
- ✅ 编译时错误检查

### 缺点
- ❌ 编译时复杂度高
- ❌ 模板代码膨胀
- ❌ 学习和维护成本高
- ❌ 编译时间长

### 适用场景
- 对性能要求极高的场景
- 需要严格类型安全
- 支持多种数据类型
- 团队C++模板技能较强

---

## 推荐的集成方案

### 设计思路
结合多种方案的优点，提供一个渐进式、向后兼容的解决方案。

### 核心代码结构

```cpp
// 1. 检查器接口
class IDataChecker {
public:
    virtual ~IDataChecker() = default;
    virtual bool check(Testexpected* my_data, const std::string& attr_name, 
                      AttrData& attr_data, std::map<std::string, AttrData>& variables) = 0;
    virtual std::string describe() const = 0;
    virtual void configure(const DynamicValue& config) {}
};

// 2. 检查器管理器
class CheckerManager {
public:
    using CheckerFactory = std::function<std::unique_ptr<IDataChecker>(const DynamicValue&)>;
    
    static CheckerManager& instance() {
        static CheckerManager manager;
        return manager;
    }
    
    void registerCheckerType(const std::string& type_name, CheckerFactory factory) {
        factories_[type_name] = factory;
    }
    
    std::unique_ptr<IDataChecker> createChecker(const std::string& pattern_string) {
        // 首先尝试从缓存获取
        auto cached = checker_cache_.find(pattern_string);
        if (cached != checker_cache_.end()) {
            return cloneChecker(cached->second.get());
        }
        
        // 解析配置并创建新的检查器
        DynamicValue config = parsePatternString(pattern_string);
        std::string type = config.get("type", DynamicValue("")).as_string();
        
        auto factory_it = factories_.find(type);
        if (factory_it == factories_.end()) {
            throw std::runtime_error("Unknown checker type: " + type);
        }
        
        auto checker = factory_it->second(config);
        
        // 缓存检查器
        checker_cache_[pattern_string] = cloneChecker(checker.get());
        
        return checker;
    }
    
    void initializeBuiltinCheckers() {
        registerCheckerType("same", [](const DynamicValue& config) {
            return std::make_unique<SameChecker>();
        });
        
        registerCheckerType("formula", [](const DynamicValue& config) {
            auto checker = std::make_unique<FormulaChecker>();
            checker->configure(config);
            return checker;
        });
        
        registerCheckerType("range", [](const DynamicValue& config) {
            auto checker = std::make_unique<RangeChecker>();
            checker->configure(config);
            return checker;
        });
        
        registerCheckerType("composite", [](const DynamicValue& config) {
            auto checker = std::make_unique<CompositeChecker>();
            checker->configure(config);
            return checker;
        });
    }
    
private:
    std::unordered_map<std::string, CheckerFactory> factories_;
    std::unordered_map<std::string, std::unique_ptr<IDataChecker>> checker_cache_;
    
    DynamicValue parsePatternString(const std::string& pattern) {
        DynamicValue config = DynamicValue::make_map();
        
        if (pattern == "SAME") {
            config["type"] = "same";
        } else if (pattern == "INLINE+CROSSLINE*2.7") {
            config["type"] = "formula";
            config["expression"] = pattern;
        } else if (pattern.find("RANGE[") == 0) {
            config["type"] = "range";
            // TODO: 解析范围参数
        } else {
            // 尝试作为YAML/JSON配置解析
            try {
                config = yaml::parse(pattern);
            } catch (...) {
                throw std::runtime_error("Invalid pattern format: " + pattern);
            }
        }
        
        return config;
    }
    
    std::unique_ptr<IDataChecker> cloneChecker(IDataChecker* original) {
        // 简化的克隆实现
        return nullptr; // 占位符
    }
};

// 3. 具体检查器实现（示例）
class SameChecker : public IDataChecker {
public:
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        return check_data_same(my_data, const_cast<std::string&>(attr_name), attr_data, variables);
    }
    
    std::string describe() const override { return "SAME"; }
};

class FormulaChecker : public IDataChecker {
public:
    bool check(Testexpected* my_data, const std::string& attr_name, 
              AttrData& attr_data, std::map<std::string, AttrData>& variables) override {
        if (expression_ == "INLINE+CROSSLINE*2.7") {
            return check_data_plus_mul(my_data, const_cast<std::string&>(attr_name), attr_data, variables);
        }
        return false;
    }
    
    void configure(const DynamicValue& config) override {
        expression_ = config.get("expression", DynamicValue("")).as_string();
    }
    
    std::string describe() const override { return "FORMULA[" + expression_ + "]"; }
    
private:
    std::string expression_;
};

// 4. 更新的主检查函数
bool check_data_new(Testexpected* my_data, const std::string& attr_name, 
                    AttrData& attr_data, std::map<std::string, AttrData>& variables, 
                    const std::string& pattern_string) {
    try {
        auto checker = CheckerManager::instance().createChecker(pattern_string);
        return checker->check(my_data, attr_name, attr_data, variables);
    } catch (const std::exception& e) {
        throw std::runtime_error("Check failed for pattern '" + pattern_string + "': " + e.what());
    }
}
```

### 配置示例

```yaml
# 简单检查器
trace_check: "SAME"

# 复杂检查器配置
complex_check:
  type: "composite"
  operator: "AND"
  checkers:
    - type: "range"
      min: 0.0
      max: 100.0
    - type: "formula"
      expression: "INLINE+CROSSLINE*2.7"

# 统计检查器
stats_check:
  type: "stats"
  min_mean: 10.0
  max_mean: 90.0
  min_std: 1.0
  max_std: 15.0
```

### 优点
- ✅ 向后兼容现有代码
- ✅ 易于扩展新检查器
- ✅ 支持配置化和硬编码两种方式
- ✅ 带缓存机制，性能优化
- ✅ 支持组合检查器
- ✅ 渐进式迁移

### 缺点
- ❌ 初期实现复杂度较高
- ❌ 需要良好的文档支持

### 适用场景
- 现有项目的升级改造
- 需要兼容性的系统
- 团队技能水平不一

---

## 实施建议

### 第一阶段：基础重构（1-2周）
1. 实现方案2（函数对象方案）
2. 替换现有的switch语句
3. 保持现有接口不变
4. 添加基本的新检查器

```cpp
// 第一阶段目标
bool check_data_v1(Testexpected* my_data, const std::string& attr_name, 
                   AttrData& attr_data, std::map<std::string, AttrData>& variables, 
                   const std::string& pattern_name) {
    // 使用函数注册表替代switch
}
```

### 第二阶段：配置化支持（2-3周）
1. 添加配置文件支持
2. 实现基本的复合检查器
3. 添加更多内置检查器类型
4. 完善错误处理和日志

```cpp
// 第二阶段目标
bool check_data_v2(Testexpected* my_data, const std::string& attr_name, 
                   AttrData& attr_data, std::map<std::string, AttrData>& variables, 
                   const DynamicValue& pattern_config) {
    // 支持YAML配置的复杂检查逻辑
}
```

### 第三阶段：性能优化（1-2周）
1. 添加缓存机制
2. 根据需要添加类型安全检查器
3. 性能分析和优化
4. 完善文档和测试

```cpp
// 第三阶段目标
bool check_data_v3(Testexpected* my_data, const std::string& attr_name, 
                   AttrData& attr_data, std::map<std::string, AttrData>& variables, 
                   const std::string& pattern_string) {
    // 高性能、完全配置化的检查系统
}
```

### 迁移策略
1. **保持兼容性**：现有的CheckPattern enum继续支持
2. **渐进迁移**：新功能使用新接口，旧功能保持不变
3. **文档先行**：为每种检查器类型提供详细文档
4. **测试覆盖**：确保所有检查器都有充分的测试

### 测试策略
```cpp
// 单元测试示例
TEST(CheckerTest, RangeChecker) {
    RangeChecker checker(0.0, 100.0);
    // ... 测试逻辑
}

TEST(CheckerTest, CompositeChecker) {
    // 测试AND/OR组合逻辑
}

TEST(CheckerTest, ConfigurationParsing) {
    // 测试配置解析
}
```

---

## 总结

通过以上四种方案的分析和推荐的集成方案，可以大大提升数据检查系统的扩展性：

1. **即时收益**：使用方案2快速替换switch语句
2. **中期目标**：实现配置驱动的复合检查器
3. **长期规划**：根据性能需求添加类型安全检查器

关键是选择适合团队技能水平和项目需求的方案，并采用渐进式的实施策略，确保系统稳定性的同时获得扩展性的提升。